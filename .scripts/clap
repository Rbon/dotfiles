#! /usr/bin/env ruby

# Main Class
class Main
  def initialize
    @args = Arguments.new(args: ARGV)
    @line = @args.input.downcase
    @grid = @line.split.map(&:chars)
    @padder = @args.padder.new(padding: @args.padding)
    @replacer = Replacer.new
    @filler = Filler.new(padding: @padder.padding)
  end

  def run
    @replacer.replace!(@grid)
    @filler.fill!(@grid)
    @padder.pad!(@grid)
    puts @grid.map { |row| row.join(" ") }.join("\n")
  end
end

# Replaces a 2D array of characters with their discord emoji version
class Replacer
  def initialize
    @replacement = ":regional_indicator_%s:"
  end

  def replace!(grid)
    grid.map! { |row| row.map { |cell| @replacement % cell } }
  end
end

# Interleaves the rows of a 2D grid with a filler value
class Filler
  def initialize(opts)
    @padding = opts[:padding]
  end

  def fill!(grid)
    return unless @padding # gotta save those CPU cycles
    grid.map! { |row| row_fill(row) }
  end

  def row_fill(row)
    row.zip(Array.new(row.length - 1) { @padding }).flatten.compact
  end
end

# Padder superclass. Holds methods for its children to use
class Padder
  attr_reader :padding

  def initialize(opts = {})
    @padding = opts[:padding] || ":clap:"
  end

  def pad!(grid)
    return unless @padding # gotta save those CPU cycles
    @width = grid.map(&:length).max
    grid.map! { |row| row_pad(row) }
  end

  def margin(row)
    [@padding] * (@width - row.length)
  end
end

# Left justifies a 2D array by padding rows with a value
class LeftPadder < Padder
  def initialize(opts = {})
    @padding = opts[:padding] || ""
  end

  def row_pad(row)
    [row, margin(row)].flatten
  end
end

# Right justifies a 2D array by padding rows with a value
class RightPadder < Padder
  def row_pad(row)
    [margin(row), row].flatten
  end
end

# Center justifies a 2D array by padding rows with a value
class MidPadder < Padder
  def row_pad(row)
    half = margin(row).slice(0, margin(row).length / 2)
    [half, row, half].flatten
  end
end

class Arguments
  attr_reader :padder, :padding, :input

  def initialize(opts)
    @pad_map = {
      "middle" => MidPadder,
      "right" => RightPadder,
      "left" => LeftPadder}
    @padding = nil
    @padder = LeftPadder
    @input = nil
    parse(opts[:args])
  end

  def parse(args)
    n = 0
    until n == args.length
      case args[n]
      when "-p"
        @padding = args[n + 1]
        n += 1
      when "-a"
        @padder = @pad_map[args[n + 1]]
        n += 1
      else
        @input = args[n]
      end
      n += 1
    end
  end
end

Main.new.run
