#! /usr/bin/env ruby

###BUGS: If youtube-dl isn't present, the script thinks everything is fine, and
###      updates the sync dates.

require "open-uri"
require "time"
require "json"

class Main
  def initialize
    @sync_time_file = File.expand_path("~/.scripts/time.txt")
    @dldb_file = File.expand_path("~/.scripts/dldb.txt")
    @dl_path = ARGV[0] || "."
    @channel_list = File.readlines(File.expand_path("~/.config/youtube-rss/channel_list.txt"))
    @feed_parser = FeedParser.new(
      channel_class: Channel,
      video_class: Video,
      last_sync_time: Time.parse(File.read(@sync_time_file)),
      dldb_file: @dldb_file,
      dl_path: @dl_path,
      cache_file: File.expand_path("~/.config/youtube-rss/cache.json")
    )
  end

  def run
    YoutubeRss.new(
      sync_time_file: @sync_time_file,
      channel_list: @channel_list,
      video_dlr: @video_dlr,
      feed_parser: @feed_parser
    ).run
  end
end

class YoutubeRss
  def initialize(opts)
    @sync_time_file = opts[:sync_time_file]
    @channel_list = opts[:channel_list]
    @feed_parser = opts[:feed_parser]
    @video_dlr = opts[:video_dlr]
  end

  def run
    @channel_list.each do |line|
      channel = @feed_parser.channel(line)
      puts channel.name
      channel.video_list.each(&:download)
    end
  end
end

class FeedParser
  def initialize(opts)
    @channel_class = opts[:channel_class]
    @video_class = opts[:video_class]
    @tag_regex = /<(?<tag>.*)>(?<value>.*)<.*>/
    @last_sync_time = opts[:last_sync_time]
    @dldb_file = opts[:dldb_file]
    @dl_path = opts[:dl_path]
    @feed_types = {
      channel: "https://www.youtube.com/feeds/videos.xml?channel_id=%s",
      user: "https://www.youtube.com/feeds/videos.xml?user=%s"
    }
    @cache_file = opts[:cache_file]
  end

  def channel(url)
    url = url.split("#")[0].strip
    type, id = url.split("/")
    feed = open(@feed_types[type.to_sym] % id) { |io| data = io.read }
    # feed = File.read("videos.xml")
    feed = feed.split("<entry>")
    data = {}
    feed[0].lines do |line|
      @tag_regex.match(line) { |match| data[match[:tag]] = match[:value] }
    end
    chan = @channel_class.new(
      id: data["yt:channelId"],
      name: data["name"],
      cache_file: @cache_file
    )
    video_list = feed.drop(1).map { |entry| video(entry, chan) }
    chan.video_list = video_list.reverse
    chan
  end

  private

  def video(info, channel)
    data = {}
    info.lines do |line|
      @tag_regex.match(line) { |match| data[match[:tag]] = match[:value] }
    end
    id = data["yt:videoId"]
    published = Time.parse(data["published"])
    @video_class.new(
      id: id,
      title: data["title"],
      published: published,
      dl_path: @dl_path,
      channel: channel
    )
  end
end

class Channel
  attr_reader :video_list, :name, :id
  attr_writer :video_list

  def initialize(opts)
    @id = opts[:id]
    @name = opts[:name]
    @video_list = opts[:video_list]
    @cache_file = opts[:cache_file]
  end

  def sync_time=(time)
    cache = File.read(@cache_file)
    cache = JSON.parse(cache)
    cache[@name] = time
    file = File.open(@cache_file, "w")
    JSON.dump(cache, file)
    file.close
  end

  def sync_time
    time = File.read(@cache_file)
    time = JSON.parse(time)[@name]
    Time.parse(time || "2018-03-01")
  end
end

class Video
  attr_reader :id, :published, :title, :description, :channel

  def initialize(opts)
    @id = opts[:id]
    @title = opts[:title]
    @description = opts[:description]
    @published = opts[:published]
    @dl_path = opts[:dl_path]
    @channel = opts[:channel]
  end

  def download
    puts "CHECKING DOWNLOAD: #{@title}"
    puts "PUBLISHED DATE: #{@published}"
    send("download_when_#{new?}")
    puts
  end

  private

  def download_when_true
    Dir.chdir(File.expand_path(@dl_path)) { system("youtube-dl #{@id}") }
    @channel.sync_time = @published
  end

  def download_when_false
  end

  def new?
    @channel.sync_time < @published
  end
end

Main.new.run
